// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
	TypedMap,
	Entity,
	Value,
	ValueKind,
	store,
	Bytes,
	BigInt,
	BigDecimal
} from '@graphprotocol/graph-ts'

export class Auction extends Entity {
	constructor(id: Bytes) {
		super()
		this.set('id', Value.fromBytes(id))
	}

	save(): void {
		let id = this.get('id')
		assert(id != null, 'Cannot save Auction entity without an ID')
		if (id) {
			assert(
				id.kind == ValueKind.BYTES,
				`Entities of type Auction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
			)
			store.set('Auction', id.toBytes().toHexString(), this)
		}
	}

	static loadInBlock(id: Bytes): Auction | null {
		return changetype<Auction | null>(
			store.get_in_block('Auction', id.toHexString())
		)
	}

	static load(id: Bytes): Auction | null {
		return changetype<Auction | null>(store.get('Auction', id.toHexString()))
	}

	get id(): Bytes {
		let value = this.get('id')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBytes()
		}
	}

	set id(value: Bytes) {
		this.set('id', Value.fromBytes(value))
	}

	get llama_id(): BigInt {
		let value = this.get('llama_id')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set llama_id(value: BigInt) {
		this.set('llama_id', Value.fromBigInt(value))
	}

	get start_time(): BigInt {
		let value = this.get('start_time')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set start_time(value: BigInt) {
		this.set('start_time', Value.fromBigInt(value))
	}

	get end_time(): BigInt {
		let value = this.get('end_time')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set end_time(value: BigInt) {
		this.set('end_time', Value.fromBigInt(value))
	}

	get total_bids(): BigInt {
		let value = this.get('total_bids')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set total_bids(value: BigInt) {
		this.set('total_bids', Value.fromBigInt(value))
	}

	get latest_bid_amount(): BigInt {
		let value = this.get('latest_bid_amount')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set latest_bid_amount(value: BigInt) {
		this.set('latest_bid_amount', Value.fromBigInt(value))
	}

	get latest_bidder(): Bytes {
		let value = this.get('latest_bidder')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBytes()
		}
	}

	set latest_bidder(value: Bytes) {
		this.set('latest_bidder', Value.fromBytes(value))
	}
}

export class CurrentAuction extends Entity {
	constructor(id: Bytes) {
		super()
		this.set('id', Value.fromBytes(id))
	}

	save(): void {
		let id = this.get('id')
		assert(id != null, 'Cannot save CurrentAuction entity without an ID')
		if (id) {
			assert(
				id.kind == ValueKind.BYTES,
				`Entities of type CurrentAuction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
			)
			store.set('CurrentAuction', id.toBytes().toHexString(), this)
		}
	}

	static loadInBlock(id: Bytes): CurrentAuction | null {
		return changetype<CurrentAuction | null>(
			store.get_in_block('CurrentAuction', id.toHexString())
		)
	}

	static load(id: Bytes): CurrentAuction | null {
		return changetype<CurrentAuction | null>(
			store.get('CurrentAuction', id.toHexString())
		)
	}

	get id(): Bytes {
		let value = this.get('id')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBytes()
		}
	}

	set id(value: Bytes) {
		this.set('id', Value.fromBytes(value))
	}

	get llama_id(): BigInt {
		let value = this.get('llama_id')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set llama_id(value: BigInt) {
		this.set('llama_id', Value.fromBigInt(value))
	}

	get start_time(): BigInt {
		let value = this.get('start_time')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set start_time(value: BigInt) {
		this.set('start_time', Value.fromBigInt(value))
	}

	get end_time(): BigInt {
		let value = this.get('end_time')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set end_time(value: BigInt) {
		this.set('end_time', Value.fromBigInt(value))
	}

	get total_bids(): BigInt {
		let value = this.get('total_bids')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set total_bids(value: BigInt) {
		this.set('total_bids', Value.fromBigInt(value))
	}

	get latest_bid_amount(): BigInt {
		let value = this.get('latest_bid_amount')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set latest_bid_amount(value: BigInt) {
		this.set('latest_bid_amount', Value.fromBigInt(value))
	}

	get latest_bidder(): Bytes {
		let value = this.get('latest_bidder')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBytes()
		}
	}

	set latest_bidder(value: Bytes) {
		this.set('latest_bidder', Value.fromBytes(value))
	}
}

export class AuctionGlobalConfiguration extends Entity {
	constructor(id: Bytes) {
		super()
		this.set('id', Value.fromBytes(id))
	}

	save(): void {
		let id = this.get('id')
		assert(
			id != null,
			'Cannot save AuctionGlobalConfiguration entity without an ID'
		)
		if (id) {
			assert(
				id.kind == ValueKind.BYTES,
				`Entities of type AuctionGlobalConfiguration must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
			)
			store.set('AuctionGlobalConfiguration', id.toBytes().toHexString(), this)
		}
	}

	static loadInBlock(id: Bytes): AuctionGlobalConfiguration | null {
		return changetype<AuctionGlobalConfiguration | null>(
			store.get_in_block('AuctionGlobalConfiguration', id.toHexString())
		)
	}

	static load(id: Bytes): AuctionGlobalConfiguration | null {
		return changetype<AuctionGlobalConfiguration | null>(
			store.get('AuctionGlobalConfiguration', id.toHexString())
		)
	}

	get id(): Bytes {
		let value = this.get('id')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBytes()
		}
	}

	set id(value: Bytes) {
		this.set('id', Value.fromBytes(value))
	}

	get min_bid_increment_percentage(): BigInt {
		let value = this.get('min_bid_increment_percentage')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set min_bid_increment_percentage(value: BigInt) {
		this.set('min_bid_increment_percentage', Value.fromBigInt(value))
	}

	get reserve_price(): BigInt {
		let value = this.get('reserve_price')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set reserve_price(value: BigInt) {
		this.set('reserve_price', Value.fromBigInt(value))
	}

	get time_buffer(): BigInt {
		let value = this.get('time_buffer')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set time_buffer(value: BigInt) {
		this.set('time_buffer', Value.fromBigInt(value))
	}

	get duration(): BigInt {
		let value = this.get('duration')
		if (!value || value.kind == ValueKind.NULL) {
			throw new Error('Cannot return null for a required field.')
		} else {
			return value.toBigInt()
		}
	}

	set duration(value: BigInt) {
		this.set('duration', Value.fromBigInt(value))
	}
}
